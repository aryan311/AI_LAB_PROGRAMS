# -*- coding: utf-8 -*-
"""AI_Week4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wKUHCWJ8OwwhV1xd6MqbKT-x-pP46pSH
"""

##ARYAN KUMAR

# installing easyAI

!pip install easyAI

"""### Write a python program to define and implement a ticâ€”tac-toe game with one human player. """

from easyAI import TwoPlayerGame
from easyAI.Player import Human_Player

#defining a class for Tic Tac Toe game and all required functions for the enviornment
class TicTacToe(TwoPlayerGame):
    """The board positions are numbered as follows:
    1 2 3
    4 5 6
    7 8 9
    """

    def __init__(self, players):
        self.players = players
        self.board = [0 for i in range(9)]
        self.current_player = 1  # player 1 starts.

    def possible_moves(self):
        return [i + 1 for i, e in enumerate(self.board) if e == 0]

    def make_move(self, move):
        self.board[int(move) - 1] = self.current_player

    def unmake_move(self, move):  # optional method (speeds up the AI)
        self.board[int(move) - 1] = 0

    def lose(self):
        """ Has the opponent "three in line ?" """
        return any(
            [
                all([(self.board[c - 1] == self.opponent_index) for c in line])
                for line in [
                    [1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9],  # horiz.
                    [1, 4, 7],
                    [2, 5, 8],
                    [3, 6, 9],  # vertical
                    [1, 5, 9],
                    [3, 5, 7],
                ]
            ]
        )  # diagonal

    def is_over(self):
        return (self.possible_moves() == []) or self.lose()

    def show(self):
        print(
            "\n"
            + "\n".join(
                [
                    " ".join([[".", "O", "X"][self.board[3 * j + i]] for i in range(3)])
                    for j in range(3)
                ]
            )
        )

    def scoring(self):
        return -1 if self.lose() else 1

from easyAI import AI_Player, Negamax

if __name__ == "__main__":
    TicTacToe([Human_Player(), AI_Player(Negamax(5))]).play()

"""### Solve the game using the built in algorithms and compare the solutions.

#### Iterative Deepening Search
"""

from easyAI import solve_with_iterative_deepening
r,d,m = solve_with_iterative_deepening(
    game=TicTacToe([]),
    ai_depths=range(2,9),
    win_score=100
)

"""#### Depth First search"""

from easyAI import solve_with_depth_first_search
u = solve_with_depth_first_search(
    game=TicTacToe([]),
    win_score=100
)
print(u)

"""#### Depth First search v/s Iterative Deepening Search

#### Depth First search
In a DFS, we start at the initial node in the graph and keep going on to explore deeper and deeper into the graph while we are able to find new and unexplored nodes or we find the solution. 

If the search algorithm runs out of branches to explore, it will backtrack to the last point where it could go down a different branch and explores from there. 

This causes problems for large graphs, as DFS might explore the entire graph along one path only to find the solution after looking at each node. If the graph is infinite, the search might not terminate. This path may not be the most optimal path to the solution either.

#### Iterative Deepening Search
Iterative deepening uses solves this problem by limiting the depth of any one path taken by the DFS and increases this limit iteratively. 

This ensures that we never explore nodes that have a distance greater than a certain threshold for any iven iteration, meaning that we never explore out infinitely. 

This means that we never end up exploring along infinite dead-end paths, since the length of each path is capped by some length at each iteration. It also means that we find the shortest possible path to the solution.
"""